name: Release Workflow - Tag, Deploy & Back-merge

on:
  # Trigger when hotfix/release branches are pushed (to create PR to main)
  push:
    branches:
      - 'release/*'
      - 'hotfix/*'
  # Trigger when PR to main is closed/merged (for post-merge operations)
  pull_request:
    branches: [main]
    types: [closed]

jobs:
  # Job 1: Create PR from hotfix/release branch to main
  create-pr-to-main:
    if: github.event_name == 'push' && (startsWith(github.ref_name, 'release/') || startsWith(github.ref_name, 'hotfix/'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version and type from branch name
        id: branch_info
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          if [[ $BRANCH_NAME == release/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/release\///')
            TYPE="release"
            LABEL="release"
          elif [[ $BRANCH_NAME == hotfix/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/hotfix\///')
            TYPE="hotfix"
            LABEL="hotfix"
          fi

          # Ensure version starts with 'v'
          if [[ ! $VERSION == v* ]]; then
            VERSION="v$VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "label=$LABEL" >> $GITHUB_OUTPUT
          echo "clean_version=$(echo $VERSION | sed 's/^v//')" >> $GITHUB_OUTPUT

      - name: Check if PR already exists
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.branch_info.outputs.branch_name }}"

          # Check if there's already an open PR from this branch to main
          EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --base "main" --state open --json number --jq '.[0].number' || echo "")

          if [[ -n "$EXISTING_PR" ]]; then
            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è PR #$EXISTING_PR already exists from $BRANCH_NAME to main"
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No existing PR found, will create new one"
          fi

      - name: Create required labels if they don't exist
        if: steps.check_pr.outputs.pr_exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üè∑Ô∏è Ensuring required labels exist..."

          # Create labels if they don't exist
          gh label create "release" --description "Release branch changes" --color "0052cc" || echo "Label 'release' already exists"
          gh label create "hotfix" --description "Hotfix branch changes" --color "d93f0b" || echo "Label 'hotfix' already exists"
          gh label create "auto-generated" --description "Automatically generated by GitHub Actions" --color "bfdadc" || echo "Label 'auto-generated' already exists"

          echo "‚úÖ Label creation completed"

      - name: Create PR to main
        if: steps.check_pr.outputs.pr_exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.branch_info.outputs.branch_name }}"
          VERSION="${{ steps.branch_info.outputs.version }}"
          TYPE="${{ steps.branch_info.outputs.type }}"
          LABEL="${{ steps.branch_info.outputs.label }}"

          # Generate commit summary for the PR description
          COMMITS=$(git log --oneline main..HEAD | head -10)
          COMMIT_COUNT=$(git rev-list --count main..HEAD)

          gh pr create \
            --base main \
            --head "$BRANCH_NAME" \
            --title "$TYPE: $VERSION" \
            --body "$(cat <<EOF
          ## Summary
          $TYPE $VERSION ready for merge to main branch.

          ## Details
          - **Branch**: \`$BRANCH_NAME\`
          - **Version**: $VERSION
          - **Type**: $TYPE
          - **Commits**: $COMMIT_COUNT

          ## Recent Commits
          \`\`\`
          $COMMITS
          \`\`\`

          ## What happens after merge
          - Tag \`$VERSION\` will be created automatically
          - Deployment workflow will be triggered
          - Back-merge PR to develop will be created
          - This branch will be cleaned up

          ## Auto-generated
          This PR was automatically created when the $TYPE branch was pushed.

          **Please review and merge when ready.**
          EOF
          )" \
            --label "$LABEL" \
            --label "auto-generated"

          echo "‚úÖ PR created successfully from $BRANCH_NAME to main"

      - name: Update existing PR if needed
        if: steps.check_pr.outputs.pr_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.check_pr.outputs.pr_number }}"
          BRANCH_NAME="${{ steps.branch_info.outputs.branch_name }}"
          VERSION="${{ steps.branch_info.outputs.version }}"
          TYPE="${{ steps.branch_info.outputs.type }}"

          echo "üîÑ Updating existing PR #$PR_NUMBER with latest changes"

          # Generate commit summary for the PR description
          COMMITS=$(git log --oneline main..HEAD | head -10)
          COMMIT_COUNT=$(git rev-list --count main..HEAD)

          gh pr edit "$PR_NUMBER" \
            --title "$TYPE: $VERSION" \
            --body "$(cat <<EOF
          ## Summary
          $TYPE $VERSION ready for merge to main branch.

          ## Details
          - **Branch**: \`$BRANCH_NAME\`
          - **Version**: $VERSION
          - **Type**: $TYPE
          - **Commits**: $COMMIT_COUNT
          - **Last Updated**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')

          ## Recent Commits
          \`\`\`
          $COMMITS
          \`\`\`

          ## What happens after merge
          - Tag \`$VERSION\` will be created automatically
          - Deployment workflow will be triggered
          - Back-merge PR to develop will be created
          - This branch will be cleaned up

          ## Auto-generated
          This PR was automatically created/updated when the $TYPE branch was pushed.

          **Please review and merge when ready.**
          EOF
          )"

          echo "‚úÖ PR #$PR_NUMBER updated successfully"

  # Job 2: Handle post-merge operations (existing functionality)
  release-process:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true && (startsWith(github.head_ref, 'release/') || startsWith(github.head_ref, 'hotfix/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global init.defaultBranch main

          echo "üîß Git configuration:"
          git config --list | grep -E "user\.(name|email)"

      - name: Extract version from branch name
        id: version
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          if [[ $BRANCH_NAME == release/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/release\///')
            TYPE="release"
            BASE_BRANCH="develop"
          elif [[ $BRANCH_NAME == hotfix/* ]]; then
            VERSION=$(echo $BRANCH_NAME | sed 's/hotfix\///')
            TYPE="hotfix"
            BASE_BRANCH="main"
          fi

          # Ensure version starts with 'v'
          if [[ ! $VERSION == v* ]]; then
            VERSION="v$VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo "clean_version=$(echo $VERSION | sed 's/^v//')" >> $GITHUB_OUTPUT

      # STEP 1: CREATE TAG AND TRIGGER DEPLOYMENT
      - name: Check if tag already exists
        id: check_tag
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          if git tag -l | grep -q "^${VERSION}$"; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Tag $VERSION already exists"
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Tag $VERSION does not exist, will create"
          fi

      - name: Get previous tag for changelog
        id: previous_tag
        run: |
          # Get the most recent tag before this one
          PREVIOUS_TAG=$(git tag --sort=-version:refname | head -n1 || echo "")
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREVIOUS_TAG"

          # Determine base commit for changelog
          if [ -n "$PREVIOUS_TAG" ]; then
            BASE_COMMIT="$PREVIOUS_TAG"
          else
            # If no tags exist, use first commit
            BASE_COMMIT=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT

      - name: Generate tag message
        id: tag_info
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TYPE="${{ steps.version.outputs.type }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          BASE_COMMIT="${{ steps.previous_tag.outputs.base_commit }}"

          # Create simple tag message
          TAG_MESSAGE="$TYPE: $VERSION

          Merged PR: ${{ github.event.pull_request.html_url }}
          Merged by: @${{ github.event.pull_request.merged_by.login }}

          üöÄ Deployment will be triggered automatically."

          echo "tag_message<<EOF" >> $GITHUB_OUTPUT
          echo "$TAG_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create and push tag
        if: steps.check_tag.outputs.tag_exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          echo "üè∑Ô∏è  Creating annotated tag $VERSION..."

          # Ensure we're on the main branch and have the latest commit
          git checkout main
          echo "üìç Current commit: $(git rev-parse HEAD)"
          echo "üìç Current branch: $(git branch --show-current)"

          # Create annotated tag with message (no temporary files)
          git tag -a "$VERSION" -m "${{ steps.tag_info.outputs.tag_message }}"

          echo "üè∑Ô∏è Tag created locally. Pushing to origin..."

          # Push the tag with verbose output
          git push origin "$VERSION" --verbose

          echo "‚úÖ Tag $VERSION created and pushed successfully"
          echo "üîç Verifying tag exists on remote:"
          git ls-remote --tags origin | grep "$VERSION" || echo "‚ö†Ô∏è Tag not found in remote (may take a moment to appear)"

      - name: Trigger deployment workflow
        if: steps.check_tag.outputs.tag_exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          echo "üöÄ Triggering deployment workflow for tag $VERSION..."

          # Wait a moment for tag to be processed
          sleep 3

          # Trigger deployment workflow using workflow_dispatch
          gh workflow run deploy.yml --ref main --field tag="$VERSION"

          if [ $? -eq 0 ]; then
            echo "‚úÖ Deployment workflow triggered successfully for $VERSION"
            echo "üîç Monitor progress at: https://github.com/${{ github.repository }}/actions/workflows/deploy.yml"
          else
            echo "‚ö†Ô∏è Failed to trigger deployment workflow automatically."
            echo "üõ†Ô∏è Manual fallback steps:"
            echo "   1. Go to: https://github.com/${{ github.repository }}/actions/workflows/deploy.yml"
            echo "   2. Click 'Run workflow'"
            echo "   3. Enter tag: $VERSION"
            echo "   4. Click 'Run workflow' button"
          fi

      # STEP 2: SYNC DEVELOP WITH MAIN AND CREATE BACK-MERGE
      - name: Sync develop with main before back-merge
        id: sync_develop
        run: |
          echo "üîÑ Syncing develop with main to prevent conflicts..."

          # Fetch latest from origin - this updates remote tracking branches
          git fetch origin develop
          git fetch origin main

          # Check if develop is behind main using remote references
          BEHIND_COUNT=$(git rev-list --count origin/develop..origin/main)
          echo "behind_count=$BEHIND_COUNT" >> $GITHUB_OUTPUT

          if [ "$BEHIND_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è Develop is $BEHIND_COUNT commits behind main"
            echo "needs_sync=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Develop is up to date with main"
            echo "needs_sync=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate unique back-merge branch name
        id: branch_name
        run: |
          BASE_BRANCH="chore/back-merge-${{ steps.version.outputs.version }}-to-develop"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          UNIQUE_BRANCH="${BASE_BRANCH}-${TIMESTAMP}"

          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo "unique_branch=$UNIQUE_BRANCH" >> $GITHUB_OUTPUT
          echo "Generated unique branch name: $UNIQUE_BRANCH"

      - name: Check for existing back-merge branches
        id: check_branch
        run: |
          BASE_BRANCH="${{ steps.branch_name.outputs.base_branch }}"
          UNIQUE_BRANCH="${{ steps.branch_name.outputs.unique_branch }}"

          # Check if base branch name already exists
          if git ls-remote --heads origin "$BASE_BRANCH" | grep -q "$BASE_BRANCH"; then
            echo "base_branch_exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Base branch $BASE_BRANCH already exists, using unique name"
            FINAL_BRANCH="$UNIQUE_BRANCH"
          else
            echo "base_branch_exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Base branch $BASE_BRANCH available"
            FINAL_BRANCH="$BASE_BRANCH"
          fi

          echo "final_branch=$FINAL_BRANCH" >> $GITHUB_OUTPUT
          echo "Final branch name: $FINAL_BRANCH"

      - name: Create back-merge branch
        id: backmerge
        run: |
          BACKMERGE_BRANCH="${{ steps.check_branch.outputs.final_branch }}"
          echo "backmerge_branch=$BACKMERGE_BRANCH" >> $GITHUB_OUTPUT

          # Fetch latest from origin - this updates remote tracking branches
          git fetch origin develop
          git fetch origin main

          # Create and checkout new branch from main (not develop) to avoid conflicts
          echo "üåø Creating branch $BACKMERGE_BRANCH from main"
          git checkout -b "$BACKMERGE_BRANCH" origin/main

          # Now merge develop into this branch to see what needs to be preserved
          echo "üîÑ Checking for develop-specific changes..."

          # Try to merge develop to see if there are any develop-specific changes
          echo "üîç Checking if develop has changes that need to be preserved..."

          # Use git merge-tree to check for conflicts without actually merging
          MERGE_BASE=$(git merge-base origin/main origin/develop)

          # Check if there would be conflicts
          if git merge-tree "$MERGE_BASE" origin/main origin/develop | grep -q "<<<<<<< ";
          then
            echo "‚ö†Ô∏è Merge conflicts detected between main and develop"
            echo "üìù Creating branch from develop to preserve develop-specific changes"
            # Create from develop in this case
            git checkout -b "${BACKMERGE_BRANCH}_temp" origin/develop
            git branch -D "$BACKMERGE_BRANCH" 2>/dev/null || true
            git branch -m "${BACKMERGE_BRANCH}_temp" "$BACKMERGE_BRANCH"
          else
            # Check if develop has commits ahead of main
            DEVELOP_AHEAD_COUNT=$(git rev-list --count origin/main..origin/develop)

            if [ "$DEVELOP_AHEAD_COUNT" -gt 0 ]; then
              echo "üìù Develop has $DEVELOP_AHEAD_COUNT commits ahead of main - preserving develop changes"
              # Create from develop to preserve its changes
              git checkout -b "${BACKMERGE_BRANCH}_temp" origin/develop
              git branch -D "$BACKMERGE_BRANCH" 2>/dev/null || true
              git branch -m "${BACKMERGE_BRANCH}_temp" "$BACKMERGE_BRANCH"
            else
              echo "‚úÖ No develop-specific changes to preserve - using main as base"
              # Stay on main-based branch
            fi
          fi

          # Verify we're on the correct branch
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          if [ "$CURRENT_BRANCH" != "$BACKMERGE_BRANCH" ]; then
            echo "‚ùå Failed to create/checkout branch $BACKMERGE_BRANCH"
            exit 1
          fi

          # Now perform the actual merge based on the branch base
          CURRENT_BASE=$(git merge-base HEAD origin/main)
          MAIN_BASE=$(git merge-base origin/main origin/main)

          if [ "$CURRENT_BASE" = "$MAIN_BASE" ]; then
            echo "üîÑ Branch is based on main, merging develop changes..."
            MERGE_TARGET="origin/develop"
          else
            echo "üîÑ Branch is based on develop, merging main changes..."
            MERGE_TARGET="origin/main"
          fi

          # Attempt merge with automatic conflict resolution
          MERGE_COMMIT_MSG="chore: back-merge ${{ steps.version.outputs.version }} from main to develop

          Automated back-merge of ${{ steps.version.outputs.type }} ${{ steps.version.outputs.version }} from main branch.

          Original PR: ${{ github.event.pull_request.html_url }}
          Merged commit: ${{ github.event.pull_request.merge_commit_sha }}
          Tag created: ${{ steps.version.outputs.version }}
          Branch: $BACKMERGE_BRANCH"

          if ! git merge --no-ff "$MERGE_TARGET" -m "$MERGE_COMMIT_MSG"; then

            echo "‚ö†Ô∏è Merge conflicts detected, attempting automatic resolution..."

            # Check if we're actually in a merge state
            if [ ! -f ".git/MERGE_HEAD" ]; then
              echo "‚ùå Not in merge state but merge failed. Exiting."
              exit 1
            fi

            # For version-related conflicts, intelligently resolve based on versions
            if git status --porcelain | grep -q "package.json"; then
              echo "üîÑ Resolving version conflict in package.json..."

              # Get versions from both branches
              MAIN_VERSION=$(git show origin/main:package.json | jq -r '.version' 2>/dev/null || echo "0.0.0")
              DEVELOP_VERSION=$(git show origin/develop:package.json | jq -r '.version' 2>/dev/null || echo "0.0.0")

              echo "  Main version: $MAIN_VERSION"
              echo "  Develop version: $DEVELOP_VERSION"

              # Use the higher version number
              if [ "$(printf '%s\n' "$MAIN_VERSION" "$DEVELOP_VERSION" | sort -V | tail -n1)" = "$DEVELOP_VERSION" ]; then
                echo "  ‚úÖ Keeping develop version (higher): $DEVELOP_VERSION"
                git checkout origin/develop -- package.json
              else
                echo "  ‚úÖ Keeping main version (higher): $MAIN_VERSION"
                git checkout origin/main -- package.json
              fi
              git add package.json
            fi

            # Handle CHANGELOG.md conflicts
            if git status --porcelain | grep -q "CHANGELOG.md"; then
              echo "üîÑ Resolving CHANGELOG.md conflicts..."
              # For CHANGELOG, we want to keep all entries from both branches
              git checkout --ours CHANGELOG.md
              git add CHANGELOG.md
            fi

            # Resolve any other simple conflicts by taking "ours" (current branch)
            CONFLICTED_FILES=$(git status --porcelain | grep "^UU" | awk '{print $2}')
            if [ -n "$CONFLICTED_FILES" ]; then
              echo "üîÑ Resolving remaining conflicts by keeping current branch version..."
              for file in $CONFLICTED_FILES; do
                echo "  Resolving: $file"
                git checkout --ours "$file"
                git add "$file"
              done
            fi

            # Check if all conflicts are resolved
            if git status --porcelain | grep -q "^UU\|^AA"; then
              echo "‚ùå Some conflicts still remain unresolved"
              git status --porcelain
              echo "üîÑ Aborting merge and creating branch for manual resolution"
              git merge --abort

              # Create a simple branch from current state for manual review
              echo "üìù Creating back-merge branch without conflicts for manual review"
            else
              # All conflicts resolved, complete the merge
              echo "‚úÖ All conflicts resolved, completing merge..."
              git commit -m "$MERGE_COMMIT_MSG"
            fi
          else
            echo "‚úÖ Merge completed successfully without conflicts"
          fi

          # Push the back-merge branch
          echo "‚¨ÜÔ∏è  Pushing $BACKMERGE_BRANCH to origin"
          git push origin "$BACKMERGE_BRANCH"

          echo "‚úÖ Back-merge branch created and pushed successfully"

      - name: Create required labels if they don't exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üè∑Ô∏è Ensuring required labels exist for back-merge PR..."

          # Create labels if they don't exist
          gh label create "chore" --description "Maintenance and chore tasks" --color "0e8a16" || echo "Label 'chore' already exists"
          gh label create "auto-generated" --description "Automatically generated by GitHub Actions" --color "bfdadc" || echo "Label 'auto-generated' already exists"

          echo "‚úÖ Label creation completed"

      - name: Create back-merge PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BACKMERGE_BRANCH="${{ steps.backmerge.outputs.backmerge_branch }}"
          BASE_BRANCH_EXISTS="${{ steps.check_branch.outputs.base_branch_exists }}"

          # Add branch conflict info to description if needed
          if [[ "$BASE_BRANCH_EXISTS" == "true" ]]; then
            BRANCH_INFO="- **Branch**: \`$BACKMERGE_BRANCH\` ‚ö†Ô∏è (unique name due to conflict)"
          else
            BRANCH_INFO="- **Branch**: \`$BACKMERGE_BRANCH\`"
          fi

          gh pr create \
            --base develop \
            --head "$BACKMERGE_BRANCH" \
            --title "chore: back-merge ${{ steps.version.outputs.version }} from main to develop" \
            --body "$(cat <<EOF
          ## Summary
          Automated back-merge of ${{ steps.version.outputs.type }} ${{ steps.version.outputs.version }} from main to develop branch.

          ## Details
          - **Original PR**: ${{ github.event.pull_request.html_url }}
          - **Merged Branch**: \`${{ steps.version.outputs.branch_name }}\`
          - **Version**: ${{ steps.version.outputs.version }}
          - **Type**: ${{ steps.version.outputs.type }}
          - **Merge Commit**: ${{ github.event.pull_request.merge_commit_sha }}
          - **Tag Created**: ${{ steps.check_tag.outputs.tag_exists == 'false' && '‚úÖ Yes' || '‚ö†Ô∏è Already existed' }}
          $BRANCH_INFO

          ## What this PR does
          - Syncs develop branch with main after ${{ steps.version.outputs.type }} merge
          - Ensures develop has all changes from the ${{ steps.version.outputs.version }} ${{ steps.version.outputs.type }}
          - Maintains Git Flow branching model integrity
          - Automatically resolves common version conflicts (keeps develop version if newer)

          ## Auto-generated
          This PR was automatically created by GitHub Actions.

          **Review and merge when ready** - this should typically be a straightforward merge unless there are conflicts that need manual resolution.
          EOF
          )" \
            --label "chore" \
            --label "auto-generated"

      # STEP 3: CLEANUP MERGED BRANCH
      - name: Delete merged release/hotfix branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.version.outputs.branch_name }}"

          echo "üßπ Cleaning up merged branch: $BRANCH_NAME"

          # Delete the remote branch
          git push origin --delete "$BRANCH_NAME" || echo "‚ö†Ô∏è  Branch $BRANCH_NAME may have already been deleted"

          echo "‚úÖ Branch cleanup completed"

      - name: Create workflow summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TYPE="${{ steps.version.outputs.type }}"
          BRANCH_NAME="${{ steps.version.outputs.branch_name }}"
          BACKMERGE_BRANCH="${{ steps.backmerge.outputs.backmerge_branch }}"
          BASE_BRANCH_EXISTS="${{ steps.check_branch.outputs.base_branch_exists }}"

          echo "## üöÄ Release Workflow Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "**Type**: $TYPE" >> $GITHUB_STEP_SUMMARY
          echo "**Original Branch**: \`$BRANCH_NAME\` (cleaned up)" >> $GITHUB_STEP_SUMMARY
          echo "**Back-merge Branch**: \`$BACKMERGE_BRANCH\`" >> $GITHUB_STEP_SUMMARY
          echo "**Merge Commit**: \`${{ github.event.pull_request.merge_commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Completed Actions" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.check_tag.outputs.tag_exists }}" == "true" ]]; then
            echo "- ‚ö†Ô∏è  Tag \`$VERSION\` already existed (no new deployment)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üè∑Ô∏è Created and pushed tag \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
            echo "- üöÄ Triggered deployment workflow" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$BASE_BRANCH_EXISTS" == "true" ]]; then
            echo "- üîÑ Created back-merge PR to develop (unique branch name due to conflict)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üîÑ Created back-merge PR to develop" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- üßπ Deleted merged branch \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. üîç [Monitor deployment progress](${{ github.server_url }}/${{ github.repository }}/actions)" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚úÖ Review and merge the back-merge PR to develop" >> $GITHUB_STEP_SUMMARY
          echo "3. üéâ Release process complete!" >> $GITHUB_STEP_SUMMARY
